[TOC]

# 应用开发示例

本章节里，我们通过几个典型的应用任务，展示“格物”平台的开发流程和功能特性。

## 使用BFV算法计算乘法

本节里我们演示一个简单的例子，完成一个BFV的密文乘法。

对不同的算力芯片，格物平台支持相同的开发流程，分为离线和在线两个阶段。此外，对CPU算力，平台也支持不使用FHE指令编译器的开发流程。接下来，我们分别演示不使用FHE指令编译器和使用FHE指令编译器的情况，如何完成一个BFV的密文乘法。

### 不使用FHE指令编译器的开发流程

计算BFV密文乘法可以分为下面4个步骤：

步骤一：用户首先需选择合适的同态参数，在选择多项式阶数$n$和明文模数$t$后，使用`create_parameter(n, t)`生成同态参数，然后调用`create_random_context(param)`生成对应的context。完成这两步操作后才能进行后续的基本运算操作。level在示例中表示BFV算法中一个明文或密文的RNS分量个数减一，最高的level可以通过`BfvParameter::get_max_level()`函数获得。本例中我们使用`level = 3`。后面编码的时候需要指定明文的level。

```C++
uint64_t t = 0x1b4001;
uint64_t n = 16384;
BfvParameter param = BfvParameter::create_parameter(n, t);
BfvContext context = BfvContext::create_random_context(param);
int level = 3;
```

步骤二：在这个示例中，我们计算两个整数乘法 $5 \times 2$ 和 $10 \times 3$ 。此时我们可以使用BFV算法的SIMD特性，将(5,10)打包成一个密文，将(2,3)打包成另一个密文，当两个密文进行同态乘法时，对应的分量也完成相应的乘法运算。具体而言，我们首先需要对消息数据进行编码`encode()`得到明文对象，之后再对明文对象进行加密`encrypt_asymmetric()`得到密文对象，这里使用的`encrypt_asymmetric()`表示非对称加密，在SDK中也有对称加密函数`encrypt_symmetric()`。

```C++
vector<uint64_t> x_mg({5, 10});
vector<uint64_t> y_mg({2, 3});
BfvPlaintext x_pt = context.encode(x_mg, level);
BfvPlaintext y_pt = context.encode(y_mg, level);   
BfvCiphertext x_ct = context.encrypt_asymmetric(x_pt);
BfvCiphertext y_ct = context.encrypt_asymmetric(y_pt);
```

步骤三：使用`mult()`对密文进行乘法操作。BFV算法的乘法算子结果是3个多项式的密文，而我们希望密文保持为2个多项式，所以需使用`relinearize()`对结果密文进行重线性化操作。

```C++
BfvCiphertext3 z_ct3 = context.mult(x_ct, y_ct);
BfvCiphertext z_ct = context.relinearize(z_ct3);
```

步骤四：为了验证结果的正确性，我们需要将密文还原为明文结果数据，因此需要先解密`decrypt()`得到明文，再对明文进行解码`decode()`得到数据消息。

```C++
BfvPlaintext z_pt = context.decrypt(z_ct);
vector<uint64_t> z_mg = context.decode(z_pt);
print_message(z_mg.data(), "z_mg", 2);  // 打印结果为 x2_mg = [10, 30, ...]
```

这一过程和目前大多数的同态算法库都是类似的。

### 使用FHE指令编译器的开发流程

这里我们使用格物平台，调用CPU完成一个BFV的密文乘法。

**离线阶段：自定义计算任务**

在选定同态参数后，用户编写一个Python程序，描述抽象计算流程。一般地，这个抽象计算流程可以看成一个由抽象数据节点和抽象计算节点构成的有向无环图。然后调用库函数，对自定义计算任务做转译和编译。

一个BFV密文乘法的抽象计算图可以表示成下图。

![fhe_pipeline](image-20231205120746833.png)

图中的3个密文数据节点假设都处在level 3。这个计算图可以用以下代码表示：

```python
level = 3
x = BfvCiphertextNode('x', level)
y = BfvCiphertextNode('y', level)
z = mult_relin(x, y, 'z')
```

对于这个计算图的数据x和y，需要构造两个数据节点。`z = mult_relin(x, y, 'z')`这行代码定义了一个计算节点，以及此计算节点的输出数据节点。已知计算节点的类型和输入数据节点的类型及level，其输出数据节点的类型及level可以推断出来，所以中间数据节点和输出数据节点不需要单独定义。

对于本例，描述完成抽象计算图后，需要设置全局FHE参数，然后调用`process_custom_task()`库函数，生成对应的FHE算子指令，输出到指定目录：

```Python
# 设置全局参数（自定义参数，仅用于CPU执行）
param = Param.create_bfv_custom_param(
    n=8192,
    p=[0x7ffffffffb4001],
    q=[0x3fffffffef8001, 0x4000000011c001, 0x40000000120001],
    t=0x28001
)
set_fhe_param(param)

# 编译任务
process_custom_task(
    input_args=[Argument('x', x), Argument('y', y)],
    output_args=[Argument('z', z)],
    output_instruction_path='examples/bfv_mult',
    fpga_acc=False,
)
```
这里`fpga_acc = False`表示这是一个由CPU或GPU执行的任务，而`param = Param.create_bfv_custom_param( ...`是用户完全自定义选择的同态参数，当然，格物平台也支持用户只根据多项式阶数来选择默认参数。

**在线阶段：调用算力芯片执行自定义任务**

在在线阶段，用户在应用程序中载入自定义任务，输入具体的数据，调用合适的算力执行自定义任务并获得输出数据。

本例的在线阶段代码与上一个例子[不使用FHE指令编译器的开发流程](#不使用FHE指令编译器的开发流程)的步骤一、二、四完全相同，只有步骤三密文计算步骤不同。

步骤三：载入在离线阶段生成的计算任务，

```C++
FheTaskCpu project("example/bfv_mult");
```

执行计算前，输入输出数据需要与抽象自定义任务中的对象对应起来。对于本例中的输出数据`z_ct`，我们需要用`new_ciphertext()`创建一个新的密文与之对应。在自定义任务里，密文乘法的输入输出数据分别被命名为"x"、"y"、"z"，在在线阶段代码里，它们分别是`x_ct`、`y_ct`、`z_ct`，`vector<CxxVectorArgument> cxx_args`表示了这个对应关系。最后，我们调用`run()`成员函数，指定context和数据，在相应的算力芯片上执行密文计算。（注：在算法中，重线性化操作需要使用重线性化公钥，本例中，SDK会自动提取context里面包含的重线性化公钥，与输入数据一起载入算力芯片。）

```C++
BfvCiphertext z_ct = context.new_ciphertext(level);
vector<CxxVectorArgument> cxx_args = {
    {"x", &x_ct},
    {"y", &y_ct},
    {"z", &z_ct},
};
project.run(&context, cxx_args);
```

此后对`z_ct`做解密、解码，可以得到与上一节一致的结果。

在随后的示例中，我们只关注使用FHE指令编译器的开发流程。


## 使用BFV算法计算多项式

这个例子里，我们计算的自定义任务是一个七次多项式$y = \sum_{i=0}^7 a_i \cdot x^{i}$，其中各个系数 $a_i$ 为明文形式，数据 $x$ 为密文形式。这个七次多项式的计算包括从$x$计算$x$的各个幂次$x^i, i=2,3,\ldots,7$，以及计算各个系数$a_i$与$x^i$的密文-明文乘法及累加。这里我们演示如何尽量在最低的level上进行计算，使得密文计算量尽量小。

**离线阶段**

对于$a_i$与$x^i$的密文-明文乘法及累加，其乘法深度是1，可以在level 1上执行。计算$x$的不同的的幂次需要不同的乘法深度，经过推算，可以用下面的计算图计算各个$x^i$，其中实线表示密文乘法，虚线表示rescale：

![fhe_pipeline](image-20231205143802781.png)

下面的代码描述了整个七次多项式的计算流程：

```python
x = BfvCiphertextNode('x', 4)
a0 = BfvPlaintextNode('a_0', 1)
a = [BfvPlaintextMulNode(f'a_{i}', 1) for i in range(1, 8)]

x1_lv4 = x
x2_lv3 = rescale(mult_relin(x1_lv4, x1_lv4))
x1_lv3 = rescale(x1_lv4)
x3_lv2 = rescale(mult_relin(x1_lv3, x2_lv3))
x4_lv2 = rescale(mult_relin(x2_lv3, x2_lv3))
x2_lv2 = rescale(x2_lv3)
x5_lv1 = rescale(mult_relin(x2_lv2, x3_lv2))
x6_lv1 = rescale(mult_relin(x3_lv2, x3_lv2))
x7_lv1 = rescale(mult_relin(x3_lv2, x4_lv2))
x2_lv1 = rescale(x2_lv2)
x3_lv1 = rescale(x3_lv2)
x4_lv1 = rescale(x4_lv2)
x1_lv2 = rescale(x1_lv3)
x1_lv1 = rescale(x1_lv2)
x_powers = [x1_lv1, x2_lv1, x3_lv1, x4_lv1, x5_lv1, x6_lv1, x7_lv1]
y = a0
for i in range(7):
    y = add(y, mult(x_powers[i], a[i]))

# 设置全局参数（自定义参数，仅用于CPU执行）
param = Param.create_bfv_custom_param(
    n=8192,
    p=[0x7ffffffffb4001],
    q=[0x3fffffffef8001, 0x4000000011c001, 0x40000000120001, 0x3fffffffd08001, 0x7fffffffe90001],
    t=0x1b4001
)
set_fhe_param(param)

# 编译任务
process_custom_task(
    input_args=[Argument('x', x), Argument('a0', a0), Argument('a', a)],
    output_args=[Argument('y', y)],
    output_instruction_path='examples/bfv_poly_7',
    fpga_acc=False,
)
```

注意在本例子里

1. $a_0$参与了密文+明文，而其它的明文系数$a_i$参与了密文*明文，这两种明文的编码格式不同，在这里需要定义成不同类型的明文数据节点。
2. 明文系数$a_i$构成的列表可以作为一维数组输入给`process_custom_task()`，也支持二维、三维、四维的数据节点数组。

**在线阶段**

离线阶段完成后，在线阶段的代码与前面的例子总体结构相同：

```c++
uint64_t t = 0x1b4001;
uint64_t n = 8192;
BfvParameter param = BfvParameter::create_parameter(n, t);
BfvContext context = BfvContext::create_random_context(param);

vector<uint64_t> x_mg({1, 2, 3, 4});
vector<uint64_t> a0_mg({1, 1, 1, 1});
vector<vector<uint64_t>> a_mg;
for(int i = 0; i < 7; i++) {
  a_mg.push_back({i+2, i+2, i+2, i+2});
}
BfvPlaintext x_pt = context.encode(x_mg, 4);
BfvPlaintext a0_pt = context.encode(a0_mg, 1);
vector<BfvPlaintextMul> a_pt_mul;
for(int i = 0; i < 7; i++) {
  a_pt_mul.push_back(context.encode_mul(a_mg[i], 1));
}
BfvCiphertext x_ct = context.encrypt_asymmetric(x_pt);
BfvCiphertext y_ct = context.new_ciphertext(1);

FheTaskCpu cpu_project("examples/bfv_poly_7");
vector<CxxVectorArgument> cxx_args = {
    {"x", &x_ct},
    {"a0", &a0_pt},
    {"a", &a_pt_mul},
    {"y", &y_ct},
};
cpu_project.run(&context, cxx_args);

BfvPlaintext y_pt = context.decrypt(y_ct);
vector<uint64_t> y_mg = context.decode(y_pt);
print_message(y_mg.data(), "y_mg", 4);
```

值得注意的是

1. $a_0$参与了密文-明文加法，而其它的明文系数$a_i$参与了密文-明文乘法，需要分别使用`encode()`（$a_0$）和`encode_mul()`（$a_i$），编码成不同的明文格式。
2. 硬件任务输入参数`a_pt_mul`的类型是`vector<BfvPlaintextMul>`，这与离线阶段的一维数组参数`a`对应。

## 使用CKKS算法计算乘法

这个例子里，我们使用CPU计算一个CKKS的密文乘法并rescale。

在离线阶段，此任务的抽象计算描述可直接写出来：

```python
# 设置全局参数（自定义参数，仅用于CPU执行）
param = Param.create_ckks_custom_param(
    n=8192,
    p=[0x7ffffffffb4001],
    q=[0x3fffffffef8001, 0x4000000011c001, 0x40000000120001, 0x3fffffffd08001]
)
set_fhe_param(param)

# 定义计算图
level = 3
x = CkksCiphertextNode('x', level)
y = CkksCiphertextNode('y', level)
z = rescale(mult_relin(x, y), 'z')

# 编译任务
process_custom_task(
    input_args=[Argument('x', x), Argument('y', y)],
    output_args=[Argument('z', z)],
    output_instruction_path='examples/ckks_mult',
    fpga_acc=False,
)
```

在在线阶段，CKKS的消息数据类型是浮点数。与BFV算法的一个主要区别是，用户需要关注各个CKKS密文的scale。输入数据的default_scale由`param.get_default_scale()`获取，约等于每个密文模数分量。

```c++
double default_scale = param.get_default_scale();
...
CkksPlaintext x_pt = context.encode(x_mg, level, default_scale);
CkksPlaintext y_pt = context.encode(y_mg, level, default_scale);
```

两个scale为`default_scale`的密文经过乘法，乘积的scale是`default_scale*default_scale`。乘积密文经过rescale后，密文的level减小1，同时scale被除以当前密文模数的最后一个分量。在这里例子里，乘积密文的level是3，所以除以的模数是$q_3$。这样，计算结果的scale是$\texttt{default\_scale}^{2}/q_3$。这个scale与原始scale `default_scale`接近，但是它们之间的差距一般不能忽略。用户需要指明计算结果密文的scale，保证解密的结果正确。在声明输出密文的时候，代码如下：

```c++
CkksCiphertext z_ct = context.new_ciphertext(level - 1, default_scale * default_scale / param.get_q(level));
```

在线部分其它的代码与前面的例子相似，整体的流程如下：

```c++
uint64_t N = 8192;
CkksParameter param = CkksParameter::create_parameter(N);
CkksContext context = CkksContext::create_random_context(param);
int level = 3;
double default_scale = param.get_default_scale();

vector<double> x_mg({5.0, 10.0});
vector<double> y_mg({2.0, 3.0});
CkksPlaintext x_pt = context.encode(x_mg, level, default_scale);
CkksPlaintext y_pt = context.encode(y_mg, level, default_scale);
CkksCiphertext x_ct = context.encrypt_asymmetric(x_pt);
CkksCiphertext y_ct = context.encrypt_asymmetric(y_pt);

FheTaskCpu cpu_project("examples/ckks_mult");
CkksCiphertext z_ct = context.new_ciphertext(level - 1, default_scale * default_scale / param.get_q(level));
vector<CxxVectorArgument> cxx_args = {
    {"x", &x_ct},
    {"y", &y_ct},
    {"z", &z_ct},
};
cpu_project.run(&context, cxx_args);

CkksPlaintext z_pt = context.decrypt(z_ct);
vector<double> z_mg = context.decode(z_pt);

print_double_message(z_mg.data(), "z_mg", 2); // 打印结果为 z_mg = [10.000001, 30.000002, ...]

```

## 使用CKKS算法计算逻辑回归推理

这个例子里，我们使用CPU执行基于CKKS算法的逻辑回归推理。逻辑回归推理的计算公式是
$$
y = \mathbf{x}\cdot\mathbf{w}+b = \sum_{i=0}^{n_f-1} x_i\cdot w_i + b
$$
在两方计算的场景里，$\mathbf{x}$和$y$是密文的形式，$\mathbf{w}$和$b$是明文的形式。为了减少单次推理的通信量，我们把全部输入特征值$\mathbf{x}$编码到一条密文里的前$n_f$个槽（假设输入特征值的个数不大于一条密文里的编码槽数4096）。对应地，各个系数$\mathbf{w}$编码到一条明文的前$n_f$个槽。计算方首先计算$\mathbf{x}$的密文和$\mathbf{w}$的明文的乘积
$$
[\![\mathbf{u}_0]\!]=[\![\mathbf{x}]\!]\odot [\mathbf{w}]
$$
其中$[\![\cdot]\!]$表示对其里面的数组做编码和加密后得到的密文，$[\cdot]$表示对其里面的数组做编码后得到的明文，$\odot$表示同态乘法。这时，计算方需要把乘积$\mathbf{u}_0$的前$n_f$个值加起来，这个步骤需要对$[\![\mathbf{u}_0]\!]$做多次旋转并叠加。具体来说，记$n_f'$为不小于$n_f$的最小的2的整数幂次，在第一轮，计算方计算
$$
[\![\mathbf{u}_1]\!] = Rotate\left([\![\mathbf{u}_0]\!], \frac{n_f'}{2}\right)\oplus [\![\mathbf{u}_0]\!]
$$
其中$\oplus$表示同态加法。可以看出，$\mathbf{u}_1$的前$\frac{n_f'}{2}$个值分别是$\mathbf{u}_0$里面的2个数字的和。在第二轮，计算方计算
$$
[\![\mathbf{u}_2]\!] = Rotate\left([\![\mathbf{u}_1]\!], \frac{n_f'}{4}\right)\oplus [\![\mathbf{u}_1]\!]
$$
$\mathbf{u}_2$的前$\frac{n_f'}{4}$个值分别是$\mathbf{u}_0$里面的4个数字的和。以此类推，经过$\lceil \log_2 n_f \rceil$轮，$\mathbf{u}_{\lceil \log_2 n_f \rceil}$的第一个值是全部$n_f$个乘积的和。这时可以计算与$b$的加法
$$
[\![\mathbf{s}]\!] = [\![\mathbf{u}_{\lceil \log n_f \rceil}]\!] \oplus [(b, 0, 0, \ldots)]
$$
$s_0$的值是我们需要得到逻辑回归结果$y$。

值得注意的是，此时在$s_1$、$s_2$等结果值上，包含了关于 $\mathbf{w}$ 和 $b$ 的额外信息，如果请求方解密得到这些值，可以获得除了$y$以外的更多的模型参数信息，从而能够更容易地推导模型参数值。为了避免这个泄露，我们需要把这些分量掩盖住，计算方可以在最后乘上一个掩码，实现这个目的，
$$
[\![y]\!] = [\![\mathbf{s}]\!] \odot [(1, 0, 0, \dots)]
$$
上述流程的抽象计算描述是：

```python
level = 3
n_input_feature = 30

x = CkksCiphertextNode(level=level)
w = CkksPlaintextRingtNode()
b = CkksPlaintextNode(level=level-1)
mask = CkksPlaintextRingtNode()

u = rescale(mult(x, w))
n_rotate = math.ceil(math.log(n_input_feature, 2))
step = int(math.pow(2, n_rotate) / 2)
for _ in range(n_rotate):
    u_rot = rotate_cols(u, step)
    u = add(u, u_rot[0])
    step = step // 2
s = add(u, b)
y = rescale(mult(s, mask))

# 设置全局参数（自定义参数，仅用于CPU执行）
param = Param.create_ckks_custom_param(
    n=8192,
    p=[0x7ffffffffb4001],
    q=[0x3fffffffef8001, 0x4000000011c001, 0x40000000120001, 0x3fffffffd08001]
)
set_fhe_param(param)

# 编译任务
process_custom_task(
    input_args=[Argument('x', x), Argument('w', w), Argument('b', b), Argument('mask', mask)],
    output_args=[Argument('y', y)],
    output_instruction_path='examples/ckks_logistic_regression',
    fpga_acc=False,
)
```

在线阶段的代码结构与前面的例子类似，对各个数据做相应的编码、加密，根据计算流程配置好每个参数的scale。代码如下：

```c++
int level = 3;
int n_input_feature = 30;
uint64_t N = 8192;
CkksParameter param = CkksParameter::create_parameter(N);
CkksContext ctx = CkksContext::create_random_context(param);
double default_scale = param.get_default_scale();

vector<double> x_mg{
    0.04207487339675331,  -0.954683801149814,  0.09197705756340246, -0.27253446447507956, 0.18750564232192835,
    0.5840745966505123,   0.4062792877225865,  0.4622266401590458,  0.3727272727272728,   0.21103622577927572,
    -0.2877059569074779,  -0.7590611739745403, -0.2619328087452292, -0.45237748366635655, -0.6814087092497536,
    -0.29720311232613317, -0.7286363636363636, -0.3987497632127297, -0.3767096302133168,  -0.6339151223691666,
    0.24155104944859485,  -0.716950959488273,  0.336620349619005,   -0.09860401101061744, 0.20227167668229562,
    0.23858311261169463,  0.13722044728434502, 0.8240549828178696,  0.19692489651094025,  -0.16227207136298039};
vector<double> w_mg{
    -0.38779230675573784, -0.08020498791940865, -0.42494960644275187, -0.3011337927885834, 0.19736016953065058,
    -0.3452779920215878,  -0.678324870145478,   -0.8177783668067259,  0.15226510934692553, 0.5859673866284915,
    0.01255264233893136,  0.4752989745604508,   0.05023635251466458,  0.11310208234475544, 0.5530291648269257,
    0.12287678195417821,  0.3339257590342935,   0.07939103265266986,  0.5650923127926508,  0.44168413736941736,
    -0.5564150081657178,  -0.2552746866713479,  -0.544768402633023,   -0.3273054244777431, -0.05454841442127498,
    -0.3247696994741705,  -0.498143298043605,   -1.092540674562078,   0.08402652360008195, 0.16040344319412192};
vector<double> b_mg{0.430568328365614};
vector<double> mask{1.0};

auto x_pt = ctx.encode(x_mg, level, default_scale);
auto x_ct = ctx.encrypt_asymmetric(x_pt);
auto w_pt = ctx.encode_ringt(w_mg, default_scale);
auto b_pt = ctx.encode(b_mg, level - 1, default_scale * default_scale / param.get_q(level));
auto mask_pt = ctx.encode_ringt(mask, default_scale);
auto y_ct = ctx.new_ciphertext(
    level - 2, default_scale * default_scale * default_scale / param.get_q(level) / param.get_q(level - 1));

FheTaskCpu cpu_project("examples/ckks_logistic_regression");
vector<CxxVectorArgument> cxx_args = {
    {"x", &x_ct}, {"w", &w_pt}, {"b", &b_pt}, {"mask", &mask_pt}, {"y", &y_ct},
};
cpu_project.run(&ctx, cxx_args);

CkksPlaintext y_pt = ctx.decrypt(y_ct);
vector<double> y_mg = ctx.decode(y_pt);

print_double_message(y_mg.data(), "y_mg", 4);  // 打印结果为 y_mg = [-2.883086, 0.000002, -0.000001, -0.000002, ...]
```

## 数据序列化

在典型的两方全同态密文计算模式里，双方执行的总体计算流程如下：

1. 请求方执行密钥生成、数据编码、数据加密。
2. 请求方把公钥、密文数据发送给计算方。
3. 计算方编码自身的数据成为明文。
4. 计算方使用请求方的公钥、请求方的密文数据、自身的明文数据，执行全同态密文计算；
5. 计算方把计算结果密文发送给请求方。
6. 请求方使用私钥，解密计算结果密文并解码，得到结果数据。

在这个流程的第2步和第5步，双方需要在网络上传输公钥和密文数据。在这个例子里，我们展示对这些数据的序列化和反序列化的方法，计算方的计算任务是用软件执行一个CKKS密文乘法。

上面的总体计算流程可以分为三个阶段，对应例子里的三个函数。

```c++
int main() {
    auto data_0 = client_phase_0();
    auto data_1 = server_phase_1(&get<1>(data_0), &get<2>(data_0), &get<3>(data_0));
    client_phase_2(&get<0>(data_0), &data_1);
}
```

第一阶段里，请求方执行第1~2步，代码如下：

```c++
tuple<CkksContext, vector<uint8_t>, vector<uint8_t>, vector<uint8_t>> client_phase_0() {
    int N = 16384;
    CkksParameter param = CkksParameter::create_parameter(N);
    CkksContext ctx = CkksContext::create_random_context(param);
    int level = 3;
    double default_scale = pow(2, 32);

    vector<double> x_mg({5.0, 10.0});
    vector<double> y_mg({2.0, 3.0});
    CkksPlaintext x_pt = ctx.encode(x_mg, level, default_scale);
    CkksPlaintext y_pt = ctx.encode(y_mg, level, default_scale);
    CkksCiphertext x_ct = ctx.encrypt_asymmetric(x_pt);
    CkksCiphertext y_ct = ctx.encrypt_asymmetric(y_pt);

    CkksContext public_ctx = ctx.make_public_context();
    vector<uint8_t> public_ctx_bin = public_ctx.serialize();
    vector<uint8_t> x_bin = x_ct.serialize();
    vector<uint8_t> y_bin = y_ct.serialize();
    return {move(ctx), public_ctx_bin, x_bin, y_bin};
}
```

除了常规的密钥产生、数据编码、数据加密，请求方需要调用`make_public_context()`函数，生成一个只包含公钥信息的context。接下来，请求方把只包含公钥信息的context、x的密文、y的密文分别序列化，得到的`public_ctx_bin`、`x_bin`、`y_bin`为`vector<uint8_t>`类型，包含序列化后的二进制数据，可以用于网络传输。原始的context不需要序列化，需要保留下来用于后续的解密，所以也是返回值的一部分。

第二阶段里，计算方执行第3~5步，代码如下：

```c++
vector<uint8_t> server_phase_1(vector<uint8_t>* ctx_bin, vector<uint8_t>* x_bin, vector<uint8_t>* y_bin) {
    CkksContext public_context_de = CkksContext::deserialize(ctx_bin);
    CkksCiphertext x_ct_de = CkksCiphertext::deserialize(x_bin);
    CkksCiphertext y_ct_de = CkksCiphertext::deserialize(y_bin);
    CkksCiphertext3 z_ct3 = public_context_de.mult(x_ct_de, y_ct_de);
    CkksCiphertext z_ct = public_context_de.relinearize(z_ct3);
    vector<uint8_t> z_bin = z_ct.serialize(public_context_de.get_parameter());
    return z_bin;
}
```

这个例子里，计算方没有自身的数据需要编码。计算方需要把只包含公钥信息的context、x的密文、y的密文分别反序列化，然后可以正常地执行密文计算，最后把结果密文序列化，并返回。`z_bin`可以用于网络传输。

第三阶段里，请求方执行第6步，代码如下：

```c++
void client_phase_2(CkksContext* ctx, vector<uint8_t>* z_bin) {
    CkksCiphertext z_ct_de = CkksCiphertext::deserialize(z_bin);
    CkksPlaintext z_pt = ctx->decrypt(z_ct_de);
    vector<double> z_mg = ctx->decode(z_pt);
    print_double_message(z_mg.data(), "z_mg", 2);  // 输出为 z_mg = [10.000000, 29.999998, ...]
}
```

请求方把z的密文反序列化，然后可以用原始的context做解密和解码，得到正确的计算结果。

