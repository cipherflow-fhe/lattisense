[TOC]

# 快速开始

本章节会快速地向您介绍“格物”全同态密码开发平台(“格物”平台)，包括全同态密码技术背景介绍、“格物”平台简介、以及一个最小的开发示例。如果需要更详细地了解“格物”平台，请参考后续的章节。

## 全同态加密技术

在数据已成为现代经济和社会运行核心驱动力的今天，数据隐私与安全问题也随之变得空前重要。如何在充分利用数据价值的同时，有效保护个人隐私和商业机密，已成为全球性的挑战。传统的加密技术，如传输层安全性协议（TLS）和静态数据加密，分别保护了“传输中的数据”和“静态存储的数据”，但在“使用中的数据”这一环节，却长期存在着巨大的安全风险敞口。为了对数据进行计算和分析，我们不得不先将其解密，这无疑将敏感信息暴露给了潜在的攻击者和不可信的计算环境。全同态加密（Fully Homomorphic Encryption, FHE）技术的出现，为解决这一根本性矛盾提供了一把革命性的钥匙。

全同态加密是一种允许直接对密文进行任意计算的颠覆性加密范式。借助FHE，我们可以在不暴露原始数据内容的前提下，对加密数据执行加法、乘法等基本运算，进而组合成任意复杂的计算函数。计算结果同样以加密形式存在，只有持有密钥的用户才能解密并获取最终的明文结果。这意味着，从数据产生、传输、存储到计算的全生命周期，信息都可以保持加密状态，从而在理论上实现了“零信任”环境下的绝对数据安全。

FHE的核心特性在于其独特的“同态”属性，即加密操作和代数运算之间的结构保持性质。简单来说，对密文进行某种运算，等价于对原文进行了相同的运算：
$$
\textrm{Eval}(f, \textrm{Enc}(m_0), ..., \textrm{Enc}(m_{k-1})) = \textrm{Enc}(f(m_0, ..., m_{k-1}))
$$
其中 $\textrm{Enc}$ 是加密函数，$\textrm{Eval}$ 是在密文上执行任意函数 $f$ 的算法，而 $m$ 是原始明文数据。这一特性使得FHE被誉为密码学领域的“圣杯”，它将数据的可用性与机密性完美地统一起来，为构建下一代安全计算应用奠定了理论基石。

FHE的构想最早在1978年由Rivest、Adleman和Dertouzos提出，但在其后的三十余年里，构建一个真正可行的方案被证明是极其困难的。直到2009年，Craig Gentry在他的博士论文中首次提出了基于理想格（Ideal Lattices）的第一个可行的FHE方案，才标志着该领域取得了历史性的突破。Gentry的方案创造性地引入了“自举（Bootstrapping）”技术，通过对密文进行同态解密来刷新和控制计算过程中不断累积的“噪声”，从而实现了对任意深度电路的计算支持。这一开创性工作，也奠定了现代FHE技术几乎都基于“格密码”这一数学难题的根基。

自Gentry的突破以来，FHE技术经历了数代高速发展，性能和易用性得到了显著提升：

- **第一代FHE：** 以Gentry的原始方案为代表，证明了FHE的可行性，但其巨大的计算开销和密钥尺寸使其停留在理论验证阶段，远无法实际应用。
- **第二代FHE：** 约在2011-2013年间，涌现出了一系列基于带错误学习（LWE）和环上带错误学习（RLWE）问题的方案，如BGV和BFV。这些方案通过引入模切换（Modulus Switching）、密钥切换（Key Switching）和重线性化（Relinearization）等关键技术，极大地优化了噪声管理和计算效率，使得FHE在特定场景下的应用成为可能。这一代的方案主要面向精确的整数运算。
- **第三代FHE：** 关注于提升自举过程的速度和效率。以FHEW和TFHE方案为代表，它们将自举时间从数分钟缩短至亚秒级，显著降低了执行复杂逻辑门运算的成本，尤其适用于布尔电路和查找表的同态评估。
- **第四代FHE：** 以CKKS方案为代表，开辟了面向近似计算的新方向。CKKS允许对浮点数或实数进行同态加密和计算，虽然计算过程中会引入可控的近似误差，但这也拓展了FHE在机器学习、科学计算等领域的应用潜力。

当前，FHE技术正处在一个从学术研究走向产业化应用的关键时期。虽然其性能与明文计算相比仍有数量级的差距，但随着算法的持续优化、硬件加速的发展、FHE应用方案的完善、以及标准化进程的推进，FHE的性能瓶颈正在被不断突破。全球领先的科技公司、学术机构和初创企业纷纷投入研发，开源社区也涌现出如HElib、SEAL、OpenFHE、TFHE-rs等一系列成熟的FHE库，极大地降低了开发者探索和应用FHE的门槛。

## “格物”全同态密码开发平台

“格物”全同态密码开发平台（“格物”平台）向全同态密码开发者提供全面的底层技术工具，包括全同态密码算法的软件开发框架、硬件加速解决方案、应用任务编译调度框架。

全同态密码技术作为一种具有广阔前景的前沿技术，在应用开发中主要面临两方面的困难：
1. 相对明文计算，全同态密码计算的计算量升高了数个数量级，即使利用了算法和软件层面的各种优化方法后，密文上计算性能仍然是一个主要的性能瓶颈；
2. 全同态密码虽然能够支持通用的计算任务，但是为了达到最优性能，需要精密地选择任务中各个步骤的密码协议、同态参数、编码方法等，这些问题涉及到较多的FHE专业知识和复杂的全局优化问题。

针对上述难点，"格物"平台在全面支持全同态算法 BFV、CKKS 的基础上，提供了两方面的主要功能：
1. 构建了一套异构硬件加速平台，通过统一的接口，支持多种算力芯片执行FHE计算。CPU任务调度组件支持充分利用CPU多核资源，并行实现FHE任务的处理；GPU加速支持可以进一步提升大规模计算任务的性能。
2. 基于"格物"平台，"格物"系列产品提供了多个应用开发框架，包括"格物致数"密文查询框架、"格物致慧"AI模型安全推理框架，实现了数据库和AI模型推理领域的各种典型任务的FHE密文计算最优流程，让开发者可以专注于更上层的方案设计。

## 格物平台开发示例

这节里，我们通过一个简单的例子介绍格物平台的基本使用方式。我们使用 BFV 算法，对整型数据 $x$, $y$ 在密文上做乘法：首先对 $x$ 和 $y$ 分别进行编码以及加密得到对应的密文 $[\![x]\!]$ 和 $[\![y]\!]$，随后计算密文乘法 $[\![x]\!] \times [\![y]\!]$，计算结果经过解密以及解码后可还原得到明文结果 $x\times y$。

在格物平台上，我们取 $x=3, y=5$，使用 CPU 执行这个密文计算。我们需要两部分代码。第一部分离线部分，为通过 Python 代码定义需要在密文上计算的任务。

```python
# 设置全局FHE参数
param = Param.create_bfv_default_param(n=16384)
set_fhe_param(param)

# 定义计算任务 z = x * y
level = 3
x = BfvCiphertextNode('x', level)
y = BfvCiphertextNode('y', level)
z = mult_relin(x, y, 'z')

# 将上面的FHE计算任务编译成CPU上的FHE计算流程
process_custom_task(
    input_args=[Argument('x', x), Argument('y', y)],
    output_args=[Argument('z', z)],
    output_instruction_path='quick_start',
)
```

第二部分为在线部分，通过 Runtime 组件调用算力芯片进行密文计算。在本例里，

```c++
#include <cxx_sdk_v2/cxx_fhe_task.h>
#include <fhe_ops_lib/fhe_lib_v2.h>

using namespace std;
using namespace cxx_sdk_v2;

// 初始化BFV所需要的一些参数
uint64_t t = 65537;
uint64_t n = 16384;
BfvParameter param = BfvParameter::create_parameter(n, t);
BfvContext context = BfvContext::create_random_context(param);
int level = 3;

// 初始化向量x, y
vector<uint64_t> x_mg({3});  // x_mg = [3, 0, 0, ...]
vector<uint64_t> y_mg({5});  // y_mg = [5, 0, 0, ...]

// 向量x编码与加密
BfvPlaintext x_pt = context.encode(x_mg, level);
BfvCiphertext x_ct = context.encrypt_asymmetric(x_pt);

// 向量y编码与加密
BfvPlaintext y_pt = context.encode(y_mg, level);
BfvCiphertext y_ct = context.encrypt_asymmetric(y_pt);

// 分配z密文的空间
BfvCiphertext z_ct = context.new_ciphertext(level);

// 调用CPU执行计算任务
FheTaskCpu cpu_project("quick_start");
vector<CxxVectorArgument> cxx_args = {
    {"x", &x_ct},
    {"y", &y_ct},
    {"z", &z_ct},
};
cpu_project.run(&context, cxx_args);

// 解密并解码z的密文， 最终得到x与y的乘积
BfvPlaintext z_pt = context.decrypt(z_ct);
vector<uint64_t> z_mg = context.decode(z_pt);
print_message(z_mg.data(), "z_mg", 3);  // 打印结果为 z_mg = [15, 0, 0, ...]
```

